= Multi-signature Legacy 2 of 4
:page-codeurl: {codebaseurl}multisig_p2sh_2_4.js

include::bitcoinjs-guide:ROOT:partial$start-help.adoc[]

Let's create, fund and spend a 2 of 4 multi-signature with a legacy P2SH transaction.


== Creating and Funding the P2SH

.Import libraries, test wallets and set the network
[source,javascript]
----
const bitcoin = require('bitcoinjs-lib')
const {alice, bob, carol, dave} = require('./wallets.json')
const network = bitcoin.networks.regtest
----

.Create the redeem script with the special `p2ms` payment method.
[source,javascript]
----
const p2ms = bitcoin.payments.p2ms({
   m: 2, pubkeys: [
    Buffer.from(alice[1].pubKey, 'hex'),
    Buffer.from(bob[1].pubKey, 'hex'),
    Buffer.from(carol[1].pubKey, 'hex'),
    Buffer.from(dave[1].pubKey, 'hex'),
  ], network})

console.log('Redeem script:')
console.log(p2ms.output.toString('hex'))
----

.Check the redeem script.
[source,bash]
----
decodescript SCRIPT
----

The asm field should contain:
....
02 03745c9aceb84dcdeddf2c3cdc1edb0b0b5af2f9bf85612d73fa6394758eaee35d 027efbabf425077cdbceb73f6681c7ebe2ade74a65ea57ebcf0c42364d3822c590
023a11cfcedb993ff2e7523f92e359c4454072a66d42e8b74b4b27a8a1258abddd 02e9d617f38f8c3ab9a6bde36ce991bafb295d7adba457699f8620c8160ec9e87a 04
OP_CHECKMULTISIG
....

Feed the `p2sh` method with the BitcoinJS `p2ms` object. The `p2sh` method generates an object that contains the P2SH address.

[source,javascript]
----
const p2sh = bitcoin.payments.p2sh({redeem: p2ms, network})
console.log('P2SH address')
console.log(p2sh.address)
----

.Send 1 BTC to this P2SH address.
[source,bash]
----
sendtoaddress 2NAjnUkVxAv34bnfpC1edhW5qstF2QHSUk5 1
----

.Get the output index so that we have the outpoint (txid / vout).
[source,bash]
----
gettransaction TX_ID
----

TIP: Find the output index (or vout) under menu:details[vout].


== Preparing the spending transaction

Let's now prepare the spending transaction by setting input and output and having two people (private keys) to sign the transaction.
In this tutorial, alice_1 and bob_1 will redeem the P2SH multi-signature and send the funds to alice_2 P2WPKH address.

.Create the PSBT by filling TX_ID, TX_OUT and TX_HEX.
[source,javascript]
----
const psbt = new bitcoin.Psbt({network})
  .addInput({
    hash: 'TX_ID',
    index: TX_VOUT,
    redeemScript: p2sh.redeem.output,
    nonWitnessUtxo:  Buffer.from('TX_HEX', 'hex')
  }) // <1>
  .addOutput({
    address: alice[2].p2wpkh,
    value: 999e5,
  }) // <2>
----
<1> Input referencing the outpoint of our P2SH UTXO.
<2> Output locking the funds to alice_2 P2WPKH address, leaving 100 000 satoshis as mining fees

.Prepare signers Alice_1 and Bob_1 keypairs.
[source,javascript]
----
const keyPairAlice1 = bitcoin.ECPair.fromWIF(alice[1].wif, network)
const keyPairBob1 = bitcoin.ECPair.fromWIF(bob[1].wif, network)
----

.Alice_1 and bob_1 now sign the same input.
[source,javascript]
----
psbt
  .signInput(0, keyPairAlice1)
  .signInput(0, keyPairBob1)
----

.Finalize the PSBT.
[source,javascript]
----
psbt.validateSignaturesOfInput(0, Buffer.from(alice[1].pubKey, 'hex'))
psbt.validateSignaturesOfInput(0, Buffer.from(bob[1].pubKey, 'hex'))

psbt.finalizeAllInputs()
----

.Extract the transaction and get the raw hex serialization.
[source,javascript]
----
console.log('Transaction hexadecimal:')
console.log(psbt.extractTransaction().toHex())
----

.Inspect the raw transaction with Bitcoin Core CLI, check that everything is correct.
[source,bash]
----
decoderawtransaction TX_HEX
----


== Broadcasting the transaction

.It's time to broadcast the transaction via Bitcoin Core CLI.
[source,bash]
----
sendrawtransaction TX_HEX
----

.Inspect the transaction.
[source,bash]
----
getrawtransaction TX_ID true
----


== Observations

We can see that the unlocking script contains

* At the very beginning a useless but mandatory `00` value (due to a bug in `OP_CHECKMULTISIG`)
* Alice_1 and bob_1 signatures
* The redeem script